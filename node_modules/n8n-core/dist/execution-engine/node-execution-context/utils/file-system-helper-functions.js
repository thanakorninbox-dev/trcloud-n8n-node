"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileSystemHelperFunctions = void 0;
const backend_common_1 = require("@n8n/backend-common");
const config_1 = require("@n8n/config");
const di_1 = require("@n8n/di");
const n8n_workflow_1 = require("n8n-workflow");
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_os_1 = require("node:os");
const node_path_1 = require("node:path");
const constants_1 = require("../../../constants");
const instance_settings_1 = require("../../../instance-settings");
const getAllowedPaths = () => {
    const { restrictFileAccessTo } = di_1.Container.get(config_1.SecurityConfig);
    if (restrictFileAccessTo === '')
        return [];
    const allowedPaths = restrictFileAccessTo
        .split(';')
        .map((path) => path.trim())
        .filter((path) => path)
        .map((path) => (path.startsWith('~') ? path.replace('~', (0, node_os_1.homedir)()) : path));
    return allowedPaths;
};
async function resolvePath(path) {
    try {
        return (await (0, promises_1.realpath)(path));
    }
    catch (error) {
        if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
            return (0, node_path_1.resolve)(path.toString());
        }
        throw error;
    }
}
function isFilePatternBlocked(resolvedFilePath) {
    const { blockFilePatterns } = di_1.Container.get(config_1.SecurityConfig);
    return blockFilePatterns
        .split(';')
        .map((pattern) => pattern.trim())
        .filter((pattern) => pattern)
        .some((pattern) => {
        try {
            return new RegExp(pattern, 'mi').test(resolvedFilePath);
        }
        catch {
            return true;
        }
    });
}
function isFilePathBlocked(resolvedFilePath) {
    const allowedPaths = getAllowedPaths();
    const blockFileAccessToN8nFiles = process.env[constants_1.BLOCK_FILE_ACCESS_TO_N8N_FILES] !== 'false';
    const restrictedPaths = blockFileAccessToN8nFiles ? getN8nRestrictedPaths() : [];
    if (restrictedPaths.some((restrictedPath) => (0, backend_common_1.isContainedWithin)(restrictedPath, resolvedFilePath))) {
        return true;
    }
    if (isFilePatternBlocked(resolvedFilePath)) {
        return true;
    }
    if (allowedPaths.length) {
        return !allowedPaths.some((allowedPath) => (0, backend_common_1.isContainedWithin)(allowedPath, resolvedFilePath));
    }
    return false;
}
const getFileSystemHelperFunctions = (node) => ({
    async createReadStream(resolvedFilePath) {
        if (isFilePathBlocked(resolvedFilePath)) {
            const allowedPaths = getAllowedPaths();
            const message = allowedPaths.length ? ` Allowed paths: ${allowedPaths.join(', ')}` : '';
            throw new n8n_workflow_1.NodeOperationError(node, `Access to the file is not allowed.${message}`, {
                level: 'warning',
            });
        }
        try {
            await (0, promises_1.access)(resolvedFilePath);
        }
        catch (error) {
            throw error.code === 'ENOENT'
                ?
                    new n8n_workflow_1.NodeOperationError(node, error, {
                        message: `The file "${String(resolvedFilePath)}" could not be accessed.`,
                        level: 'warning',
                    })
                : error;
        }
        const stream = (0, node_fs_1.createReadStream)(resolvedFilePath, {
            flags: (node_fs_1.constants.O_RDONLY | node_fs_1.constants.O_NOFOLLOW),
        });
        return await new Promise((resolve, reject) => {
            stream.once('error', (error) => {
                if (error.code === 'ELOOP') {
                    reject(new n8n_workflow_1.NodeOperationError(node, error, {
                        level: 'warning',
                        description: 'Symlinks are not allowed.',
                    }));
                }
                else {
                    reject(error);
                }
            });
            stream.once('open', () => resolve(stream));
        });
    },
    getStoragePath() {
        return (0, backend_common_1.safeJoinPath)(di_1.Container.get(instance_settings_1.InstanceSettings).n8nFolder, `storage/${node.type}`);
    },
    async writeContentToFile(resolvedFilePath, content, flag) {
        if (isFilePathBlocked(resolvedFilePath)) {
            throw new n8n_workflow_1.NodeOperationError(node, `The file "${String(resolvedFilePath)}" is not writable.`, {
                level: 'warning',
            });
        }
        return await (0, promises_1.writeFile)(resolvedFilePath, content, {
            encoding: 'binary',
            flag: (flag ?? 0) | node_fs_1.constants.O_NOFOLLOW,
        });
    },
    resolvePath,
    isFilePathBlocked,
});
exports.getFileSystemHelperFunctions = getFileSystemHelperFunctions;
function getN8nRestrictedPaths() {
    const { n8nFolder, staticCacheDir } = di_1.Container.get(instance_settings_1.InstanceSettings);
    const restrictedPaths = [n8nFolder, staticCacheDir];
    if (process.env[constants_1.CONFIG_FILES]) {
        restrictedPaths.push(...process.env[constants_1.CONFIG_FILES].split(','));
    }
    if (process.env[constants_1.CUSTOM_EXTENSION_ENV]) {
        const customExtensionFolders = process.env[constants_1.CUSTOM_EXTENSION_ENV].split(';');
        restrictedPaths.push(...customExtensionFolders);
    }
    if (process.env[constants_1.BINARY_DATA_STORAGE_PATH]) {
        restrictedPaths.push(process.env[constants_1.BINARY_DATA_STORAGE_PATH]);
    }
    if (process.env[constants_1.UM_EMAIL_TEMPLATES_INVITE]) {
        restrictedPaths.push(process.env[constants_1.UM_EMAIL_TEMPLATES_INVITE]);
    }
    if (process.env[constants_1.UM_EMAIL_TEMPLATES_PWRESET]) {
        restrictedPaths.push(process.env[constants_1.UM_EMAIL_TEMPLATES_PWRESET]);
    }
    return restrictedPaths;
}
//# sourceMappingURL=file-system-helper-functions.js.map